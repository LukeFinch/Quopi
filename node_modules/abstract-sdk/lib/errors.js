"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throwAPIError = throwAPIError;
exports.throwCLIError = throwCLIError;
exports.ServiceUnavailableError = exports.ForbiddenError = exports.UnauthorizedError = exports.RateLimitError = exports.NotFoundError = exports.InternalServerError = exports.APITokenError = exports.EndpointUndefinedError = exports.FileAPIError = exports.CLIPathError = exports.BaseError = exports.logCLIError = exports.logAPIError = void 0;

var _debug = require("./debug");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const logAPIError = _debug.log.extend("AbstractAPI:error");

exports.logAPIError = logAPIError;

const logCLIError = _debug.log.extend("AbstractCLI:error");

exports.logCLIError = logCLIError;

class BaseError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }

}

exports.BaseError = BaseError;

class CLIPathError extends BaseError {
  constructor() {
    super("Cannot find abstract-cli.");
  }

}

exports.CLIPathError = CLIPathError;

class FileAPIError extends BaseError {
  constructor() {
    super("This method requires an environment that supports the File API. See https://www.w3.org/TR/FileAPI/ for more information.");
  }

}

exports.FileAPIError = FileAPIError;

class EndpointUndefinedError extends BaseError {
  constructor(endpoint, transport) {
    super(`Endpoint ${
    /* istanbul ignore next */
    endpoint ? `"${endpoint}" ` : ""}not defined in ${
    /* istanbul ignore next */
    transport ? `"${transport}"` : "any"} transport${
    /* istanbul ignore next */
    transport ? "" : "s"}.`);
  }

}

exports.EndpointUndefinedError = EndpointUndefinedError;

class APITokenError extends BaseError {
  constructor() {
    super("Cannot find API access token. Use options.accessToken or ABSTRACT_TOKEN. See https://sdk.goabstract.com/docs/authentication/ for more information.");
  }

}

exports.APITokenError = APITokenError;

class InternalServerError extends BaseError {
  constructor(path, body) {
    super("Internal server error.");

    _defineProperty(this, "data", void 0);

    this.data = {
      path,
      body
    };
  }

}

exports.InternalServerError = InternalServerError;

class NotFoundError extends BaseError {
  constructor(path, body) {
    super("Not found.");

    _defineProperty(this, "data", void 0);

    this.data = {
      path,
      body
    };
  }

}

exports.NotFoundError = NotFoundError;

class RateLimitError extends BaseError {
  constructor(path, body, response) {
    super("Too many requests.");

    _defineProperty(this, "data", void 0);

    this.data = {
      path,
      body
    };

    if (response) {
      const resetSeconds = response.headers.get("ratelimit-reset");
      this.data.resetsAt = Number(resetSeconds) * 1000;
    }
  }

}

exports.RateLimitError = RateLimitError;

class UnauthorizedError extends BaseError {
  constructor(path, body) {
    super("Unauthorized.");

    _defineProperty(this, "data", void 0);

    this.data = {
      path,
      body
    };
  }

}

exports.UnauthorizedError = UnauthorizedError;

class ForbiddenError extends BaseError {
  constructor(path, body) {
    super("Forbidden.");

    _defineProperty(this, "data", void 0);

    this.data = {
      path,
      body
    };
  }

}

exports.ForbiddenError = ForbiddenError;

class ServiceUnavailableError extends BaseError {
  constructor(path, body) {
    super("Service unavailable.");

    _defineProperty(this, "data", void 0);

    this.data = {
      path,
      body
    };
  }

}

exports.ServiceUnavailableError = ServiceUnavailableError;

async function throwAPIError(response, url, body) {
  /* istanbul ignore next */
  logAPIError.enabled && logAPIError((await response.clone().json()));

  switch (response.status) {
    case 401:
      throw new UnauthorizedError(url, body);

    case 403:
      throw new ForbiddenError(url, body);

    case 404:
      throw new NotFoundError(url, body);

    case 429:
      throw new RateLimitError(url, body, response);

    case 500:
      throw new InternalServerError(url, body);

    case 503:
      throw new ServiceUnavailableError(url, body);

    default:
      throw new Error(`Received status "${response.status}", expected 2XX`);
  }
}

function throwCLIError(response, cliPath, args) {
  /* istanbul ignore next */
  logCLIError.enabled && logCLIError(response);

  switch (response.code) {
    case "unauthorized":
      throw new UnauthorizedError(cliPath, args);

    case "forbidden":
      throw new ForbiddenError(cliPath, args);

    case "not_found":
      throw new NotFoundError(cliPath, args);

    case "too_many_requests":
      throw new RateLimitError(cliPath, args);

    case "service_unavailable":
      throw new ServiceUnavailableError(cliPath, args);

    default:
      throw new Error("An unexpected error has occurred.");
  }
}